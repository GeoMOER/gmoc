# Data Visualization

```{r knitsetup, echo = FALSE, message = FALSE}
pkg <- c('ggplot2', 'latticeExtra', 'gridExtra', 'MASS', 
         'colorspace', 'plyr', 'Hmisc', 'scales')
jnk <- sapply(pkg, library, character.only = TRUE)

theme_set(theme_grey())
```

In the next few sections, we will produce several varieties of *scatter plots*, *box-and-whisker plots* (from here on after 'boxplots'), *histograms* and *density plots*, and *plots with error bars*. All of these will first be produced using the **lattice** package and then an attempt is made to recreate these in (pretty much) the exact same way in **ggplot2**. First, the default versions are created and then we will see how they can be modified in order to produce plots that satisfy the requirements of most academic journals.    

We will see that some things are easier to achieve using **lattice**, whereas other things are easier in **ggplot2**, so it is probably good advice to learn how to use both of them...


## Scatter plots (lattice)

Even with all the enhancements and progress made in the field of computer based graphics in recent years, or even decades, the best (as most intuitive) way to show the relationship between two continuous variables remains the scatter plot. Just like for the smoothest ride, the best shape of the wheel is still round.

If, from our original `diamonds` data set, we wanted to see the relation between price and carat of the diamonds (or more precisely how price is influenced by carat), we would use a scatter plot.

```{r scatter-lattice, tidy = FALSE, out.width = "80%", fis.asp = 1, fig.cap = "A basic scatter plot produced with **lattice**.", fig.align = 'center'}
scatter_lattice <- xyplot(price ~ carat, data = diamonds)
scatter_lattice
```

What we see is that, generally, lower carat values tend to be cheaper. However, there is a lot of scatter, especially at the high price end, i.e. there are diamonds of 1 carat that cost just as much as diamonds of 4 or more carat. So maybe this is a function of the cut? Let's see...

[//]: # (Another thing that we might be interested in is the nature and strength of the relationship that we see in our scatter plot. These plots are still the fundamental way of visualizing linear (and non-linear) statistics between 2 (or more) variables. In our case (and we will only be marginally touching statistics here) let's try to figure out what the linear relationship between x (cut) and y (price) is. Given that we are plotting cut on the y-axis and the general linear regression formula is ```y ~ a + b*x```, this means that we are assuming that cut is influencing (determining) price, NOT the other way round!!)

**lattice** is a very powerful package that provides a lot of flexibility and power to create all sorts of tailor-made statistical plots. In particular, it is designed to provide an easy-to-use framework for the representation of some variable(s) conditioned on some other variable(s). This means, that we can easily show the same relationship from figure 1, but this time for each of the different quality levels (the variable ```cut``` in the `diamonds` data set) into which diamonds are classified. These conditional subsets are called 'panels' in **lattice**.

This is done using the ```|``` character just after the formula expression. So the complete formula would read:

```
y ~ x | g
``` 

In other words, `y` is a function of `x` conditional to the values in `g` (where `g` is usually a factorial variable). The code below shows how all of this can be achieved, viz.

* plot ```price ~ carat``` conditional to ```cut```,
* draw the regression line for each panel, and
* also provide the R-squared value for each panel.

```{r scatter-lattice-with-panels-and-line, tidy = FALSE, fig.cap = "A panel plot showing regression lines for each panel produced with **lattice**.", fig.align = 'center'}
scatter_lattice <- xyplot(price ~ carat | cut, 
                          data = diamonds, 
                          panel = function(x, y, ...) {
                            panel.xyplot(x, y, ...)
                            lm1 <- lm(y ~ x)
                            lm1sum <- summary(lm1)
                            r2 <- lm1sum$adj.r.squared
                            panel.abline(a = lm1$coefficients[1], 
                                         b = lm1$coefficients[2])
                            panel.text(labels = 
                                         bquote(italic(R)^2 == 
                                                  .(format(r2, 
                                                           digits = 3))),
                                       x = 4, y = 1000)
                            },
                          xscale.components = xscale.components.subticks,
                          yscale.components = yscale.components.subticks,
                          as.table = TRUE)

scatter_lattice
```

This is where **lattice** becomes a bit more challenging, yet how do they say: with great power comes great complexity... Okay, maybe we didn't get this quote completely correct, but it certainly reflects the nature of **lattice**'s flexibility: A lot of things are possible, but they need a bit more effort than accepting the default settings.

Basically, what we have done here is to provide a so-called panel function (actually, we have provided 3 of them). But let's look at this step-by-step... 

As **lattice** is geared towards providing plots in small multiples (as [Edward Tufte](https://www.edwardtufte.com/tufte/) calls them) or panels, it provides an argument called `panel` to which we can assign certain functions that will be evaluated separately for each of the panels. There's a variety of pre-defined panel functions (such as the ones we used here - `panel.xyplot()`, `panel.abline()`, `panel.text()`), but we can also define our own panel functions. This is why **lattice** is so versatile and powerful. Basically, writing panel functions is just like writing any other function in R (though some limitations do exist).

The important thing to note here is that ```x``` and ```y``` in the context of panel functions refer to the ```x``` and ```y``` variables we define in the plot definition, i.e. ```x = carat``` and ```y = price```. So, for the panel functions we can use this shorthand, like as we are doing in defining our linear model as ```lm1 <- lm(y ~ x)```. This linear model will be calculated separately for each of the panels, which are basically nothing else than subsets of our data corresponding to the different levels of cut. Maybe it helps to think of this as a certain type of for loop:

```{r for-loop, eval = FALSE}
for (level in levels(cut)) 
  lm1 <- lm(price ~ carat)
```

This then enables us to access the outcome of this linear model separately for each panel and we can use ```panel.abline()``` to draw a line in each panel corresponding to the calculated model coefficients (i.e. intercept (`a`) and slope (`b`). Hence, we are drawing the regression line which represents the line of least squares for each panel separately.

The same holds true for the calculation and plotting of the adjusted R-squared value for each linear model per panel. In this case we use the ```panel.text()``` function to 'write' the corresponding value into each of the panel boxes. The location of the text is determined by the ```x = ``` and ```y = ``` arguments. This is where some care needs to be taken, as in the ```panel.text()``` call ```x``` and ```y``` don't refer to the ```x``` and ```y``` variables of the global plot function ```xyplot()``` anymore, but rather represent the locations of where to position the text within each of the panel boxes in the units used for each of the axes (in our case ```x = 4``` and ```y = 1000```).

There's two more things to note with regard to panel functions:

1. In order to draw what we originally intended to draw, i.e. the scatter plot, we need to provide a panel function that represents our initial intention. In our case this is the rather blank call ```panel.xyplot(x, y, ...)```. Without this, the points of our plot will not be drawn and we will get a plot that only shows the regression line and the text (feel free to try it!). This seems like a good place to introduce one of the most awkward (from a programming point of view) but at the same time most awesome (from a users point of view) things in the R language. The three magic dots (```...```) are a shorthand for "everything else that is possible in a certain function". This is both a very lazy and at the same time a very convenient way of passing arguments to a function. Basically, this enables us to provide any additional argument that the function might be able to understand. Any argument that ```xyplot()``` is able to evaluate (understand) can be passed in addition to ```x``` and ```y```. Try it out yourself by, for example, specifying ```col = "red"```. If we had not included ```...``` in the ```panel = function(x, y, ...)``` call, the ```col = ``` definition would not be possible. Anyway, this is only a side note that is not really related to the topic at hand, so let's move on....

2. The order in which panel functions are supplied does matter. This means that the first panel function will be evaluated (and drawn) first, then the second, then the third and so on. Hence, if we were to plot the points of our plot on top of everything else, we would need to provide the ```panel.xyplot()``` function as the last of the panel functions.

Right, so now we have seen how to use panel functions to calculate and draw things specific to each panel. One thing that you might dislike about **lattice** is the default graphical parameter settings, in particular colors. However, changing these is rather straightforward. We can easily create our own themes by replacing the default values for each of the graphical parameters individually and saving these as our own themes. The function that lets us access the default (or already modified) graphical parameter settings is called ```trellis.par.get()```. By assigning this to a new object, we can modify every entry of the default settings to our liking (remember ```str()``` provides a 'road map' for accessing individual bits of an object).

```{r latt-panel-scat2, tidy = FALSE, fig.cap = "A panel plot with modified settings of the **lattice** layout.", fig.align = 'center'}
my_theme <- trellis.par.get()
my_theme$strip.background$col <- "grey80"
my_theme$plot.symbol$pch <- 16
my_theme$plot.symbol$col <- "grey60"
my_theme$plot.polygon$col <- "grey90"

l_sc <- update(scatter_lattice, par.settings = my_theme, 
               layout = c(3, 2),
               between = list(x = 0.3, y = 0.3))

print(l_sc)
```

Apart from showing us how to change the graphical parameter settings, the above code chunk also highlights one of the very handy properties of **lattice** (which is also true for **ggplot2**). We are able to store any plot we create in an object and can refer to this object later. This enables us to simply ```update()``` the object rather than having to define it over (and over) again.

Like many other packages, **lattice** has a companion called **latticeExtra** [@Sarkar2016]. This package provides several additions and extensions to the core functionality of **lattice**. One of the very handy additions is a panel function called ```panel.smoother()``` which enables us to evaluate several linear and non-linear models for each panel individually. This means that we actually don't need to calculate these models 'by hand' for each panel, but can use this pre-defined function to evaluate them. This is demonstrated in the next code chunk.

Note that we are still calculating the linear model in order to be able to provide the R-squared value for each panel. We don't need ```panel.abline()``` to draw the regression line anymore. Actually, this is done using ```panel.smoother()``` which also provides us with an estimation of the standard error related to the mean estimation of ```y``` for each ```x```. This may be hard to see, but there is a confidence band of the standard error plotted around the regression line in each panel. 

For an overview of possible models to be specified using ```panel.smoother()```, see the corresponding help pages (`?panel.smoother`) from **latticeExtra**.

```{r latt-panel-smooth-scat, tidy = FALSE, fig.cap = "A panel plot showing regression lines and confidence intervals for each **lattice** panel.", fig.align = 'center'}
scatter_lattice <- xyplot(price ~ carat | cut, 
                          data = diamonds, 
                          panel = function(x, y, ...) {
                            panel.xyplot(x, y, ...)
                            lm1 <- lm(y ~ x)
                            lm1sum <- summary(lm1)
                            r2 <- lm1sum$adj.r.squared
                            panel.text(labels = 
                                         bquote(italic(R)^2 == 
                                                  .(format(r2, 
                                                           digits = 3))),
                                       x = 4, y = 1000)
                            panel.smoother(x, y, method = "lm", 
                                           col = "black", 
                                           col.se = "black",
                                           alpha.se = 0.3)
                            },
                          xscale.components = xscale.components.subticks,
                          yscale.components = yscale.components.subticks,
                          as.table = TRUE)

l_sc <- update(scatter_lattice, par.settings = my_theme)

print(l_sc)
```

Having a look at the scatter plots we have produced so far, there is an obvious problem. There are so many points that it is impossible to determine their actual distribution. One way to address this problem could be to plot each point in a semi-transparent manner. We have tried this potential solution and found that it does not help a great deal (but please, feel free to try this out for yourselves). Hence, we need another way to address the over-plotting of points.

A potential remedy is to map the 2-dimensional space, in which we create our plot, to a regular grid and estimate the point density in each of the cells. This can be done using a so-called 2-dimensional kernel density estimator. We won't have the time to go into much detail about this method here, but we will see how this can be done...

What is important for our purpose is that we actually need to estimate this twice. Once globally, meaning for the whole data set, in order to find the absolute extremes (minimum and maximum) of our data distribution. This is important for the color mapping, because the values of each panel need to be mapped to a common scale in order to interpret them. In other words, this way we are making sure that the similar values of our data are represented by similar shades of, let's say red. However, in order to be able to estimate the density for each of our panels we also need to do the same calculation in our panel function. 

Essentially what we are creating is a gridded data set (like a photo) of the density of points within each of the defined pixels. The **lattice** function for plotting gridded data is called ```levelplot()```. Here's the code:

```{r latt-dens-scat, tidy = FALSE, fig.cap = "A **lattice** panel plot of the point density within each panel created by `panel.levelplot()`.", fig.align = 'center'}
xy <- kde2d(x = diamonds$carat, y = diamonds$price, n = 100) 
xy_tr <- con2tr(xy)
offset <- max(xy_tr$z) * 0.2
z_range <- seq(min(xy_tr$z), max(xy_tr$z) + offset, offset * 0.01)

l_sc <- update(scatter_lattice, aspect = 1, par.settings = my_theme, 
               between = list(x = 0.3, y = 0.3),
               panel=function(x,y) {
                 xy <- kde2d(x,y, n = 100) 
                 xy.tr <- con2tr(xy)                 
                 panel.levelplot(xy_tr$x, xy_tr$y, xy_tr$z, asp = 1,
                                 subscripts = seq(nrow(xy_tr)), 
                                 contour = FALSE, region = TRUE, 
                                 col.regions = c("white", 
                                                 rev(clrs_hcl(10000))),
                                 at = z_range)
                 lm1 <- lm(y ~ x)
                 lm1sum <- summary(lm1)
                 r2 <- lm1sum$adj.r.squared
                 panel.abline(a = lm1$coefficients[1], 
                              b = lm1$coefficients[2])
                 panel.text(labels = 
                              bquote(italic(R)^2 == 
                                       .(format(r2, digits = 3))),
                            x = 4, y = 1000)
                 } 
               ) 

print(l_sc)
```

It should not go unnoted that there is a panel function in **lattice** that does this for you. The function is called ```panel.smoothScatter()``` and unless we need to specify a custom color palette, this is more than sufficient. As a hint, if you want to use this panel function with your own color palette, you need to make sure that your palette starts with white as otherwise things will look really weird...

```{r latt-smooth-scat, tidy = FALSE, fig.cap = "A **lattice** panel plot of the point density within each panel created by `panel.smoothScatter()`.", fig.align = 'center', message = FALSE}
l_sc_smooth <- update(scatter_lattice, aspect = 1, 
                      par.settings = my_theme, 
                      between = list(x = 0.3, y = 0.3),
                      panel = panel.smoothScatter)

print(l_sc_smooth)
```

This representation of our data basically adds another dimension to our plot which enables us to see that no matter which quality, most of the diamonds are actually of low carat and low price. Whether this is good or bad news depends on your interpretation (and the size of your wallet, of course).


## Scatter plots (ggplot2)

Now let's try to recreate our **lattice**-based achievements using **ggplot2**.

**ggplot2** is radically different from the way that **lattice** works. **lattice** is much closer to the traditional way of plotting in R. There are different functions for different types of plots. In **ggplot2** this is different. Every plot we want to draw is, at a fundamental level, created in exactly the same way. What differs are the subsequent calls on how to represent the individual plot components (basically ```x``` and ```y```). This means a much more consistent way of *building* visualizations, but it also means that things are rather different from what you might have learned about syntax and structure of (plotting) objects in R. But don't worry, even Tim managed to understand how things are done in **ggplot2** (and prior to writing this he had almost never used it before).

Before we get carried away too much, let's jump right into our first plot using **ggplot2**.

```{r gg-scat, tidy = FALSE, fig.cap = "A basic scatter plot created with **ggplot2**.", fig.align = 'center'}
scatter_ggplot <- ggplot(aes(x = carat, y = price), data = diamonds)

g_sc <- scatter_ggplot + geom_point()

print(g_sc)
```

Similar to **lattice**, plots are (usually) stored in objects. But that is about all the similarity there is.

Let's look at the above code in a little more detail. The first line is the fundamental definition of **what** we want to plot. We provide the 'aesthetics' for the plot via ```aes()```. We state that we want the values on the x-axis to represent carat and the y-values are price. Furthermore, we want to take these variables from the `diamonds` data set. That's basically it, and this will not change a hell of a lot in the subsequent plotting routines.

What will change in the plotting code chunks that follow is **how** we want the relationship between these variables to be represented in our plot. This is done by defining so-called 'geometries' (```geom_...()```). In this first case, we stated that we want the relationship between ```x``` and ```y``` to be represented as points, hence we used ```geom_point()```.

If we wanted to provide a plot showing the relationship between price and carat in panels representing the quality of the diamonds, we need what in **ggplot2** is called 'faceting' (i.e. panels in **lattice**). To achieve this, we simply repeat our plotting call from earlier and add another layer to the call which does the faceting.

```{r gg-facet-scat, tidy = FALSE, fig.cap = "The **ggplot2** version of a faceted plot.", fig.align = 'center'}
g_sc <- scatter_ggplot + 
  geom_point() +
  facet_wrap(~ cut)

print(g_sc)
```

By default, all plots created by `ggplot()` have a grey background. This comes in particularly handy as soon as colors are involved because it increases the contrast of the colors. However, quite some people tend to dislike the grey default theme when aiming to create a simple black-and-white scatter plot, just like in our case. Here, a white facet background seems more suitable, and luckily, **ggplot2** lets us easily change the background color using a pre-defined theme called ```theme_bw()``` (make sure to check out `?theme_bw` for a full list of available themes).

```{r gg-facet-scat-grey, tidy = FALSE, fig.cap = "The **ggplot2** version of a faceted plot with grey facet background.", fig.align = 'center'}
g_sc <- scatter_ggplot + 
  geom_point() +
  facet_wrap(~ cut) + 
  theme_bw()

print(g_sc)
```

In case you wanted to remove the horizontal and vertical grid lines as well, and hence, end up with a plain white background, an additional line `+ theme(panel.grid = element_blank())` would be required. For our purposes, however, the above plot version drawing a white instead of a grey background is totally sufficient.

In order to provide the regression line for each panel like we did in **lattice**, we need a function called ```stat_smooth()```. This is fundamentally the same function that we used earlier, as the ```panel.smoother()``` in **lattice** is based on ```stat_smooth()```.

Putting this together we could do something like this (note that we also change the number of rows and columns into which the facets should be arranged):

```{r gg-facet-smooth-scat, tidy = FALSE, fig.cap = "A faceted **ggplot2** plot with regression lines and confidence bands in each facet.", fig.align = 'center'}
g_sc <- scatter_ggplot + 
  geom_point(color = "grey60") +
  facet_wrap(~ cut, nrow = 2, ncol = 3) +
  stat_smooth(method = "lm", se = TRUE, 
              fill = "black", color = "black") + 
  theme_bw()

print(g_sc)
```

Simple and straightforward, and the result looks rather similar to the **lattice** version we created earlier.

Creating a point density scatter plot in **ggplot2** is actually a fair bit easier than in **lattice**, as **ggplot2** provides several predefined ```stat_*()``` functions. One of these is designed to create 2-dimensional kernel density estimations, just what we want. However, this is where the syntax of **ggplot2** really becomes a bit abstract. The definition of the fill argument of this call is ```..density..``` which, at least at first glance, does not seem very intuitive. 

Furthermore, it is not quite sufficient to supply the `stat_*()` function, we also need to state how to map the colors to that definition. Therefore, we need yet another layer which defines what color palette to use. As we want a continuous variable (density) to be filled with a gradient of _n_ colors, we need to use ```scale_fill_gradientn()``` in which we can define the colors we want to be used.

```{r gg-dens-scat, tidy = FALSE, fig.cap = "The **ggplot2** version of a panel plot showing point densities in each panel.", fig.align = 'center', out.width = "80%"}
g_sc <- scatter_ggplot + 
  geom_tile() +
  facet_wrap(~ cut, nrow = 3, ncol = 2) +
  stat_density2d(aes(fill = ..density..), n = 100,
                 geom = "tile", contour = FALSE) +
  scale_fill_gradientn(colors = c("white",
                                   rev(clrs_hcl(100)))) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +
  coord_fixed(ratio = 5/30000) + 
  theme_bw()

print(g_sc)
```


## Box-and-Whisker Plots (lattice)

Boxplots are probably the most useful visual way for showing the nature (or distribution) of your data and allow for some easy comparisons between different levels of a factor for example. See [Wikimedia](http://upload.wikimedia.org/wikipedia/commons/1/1a/Boxplot_vs_PDF.svg) for a visual representation of the standard R settings of boxplots in relation to mean and standard deviation of a normal distribution.

So without further ado, here's a basic **lattice** boxplot.

```{r latt-bw1, tidy = FALSE, fig.cap = "A basic boxplot produced with **lattice**.", fig.align = 'center'}
bw_lattice <- bwplot(price ~ color, data = diamonds)
bw_lattice
```

Not so very beautiful... So, let's again modify the standard ```par.settings``` so that we get an acceptable visual appearance of our boxplot. Much better, isn't it?

```{r latt-bw2, tidy = FALSE, fig.cap = "A **lattice** boxplot with modified graphical parameter settings.", fig.align = 'center'}
bw_theme <- trellis.par.get()
bw_theme$box.dot$pch <- "|"
bw_theme$box.rectangle$col <- "black"
bw_theme$box.rectangle$lwd <- 2
bw_theme$box.rectangle$fill <- "grey90"
bw_theme$box.umbrella$lty <- 1
bw_theme$box.umbrella$col <- "black"
bw_theme$plot.symbol$col <- "grey40"
bw_theme$plot.symbol$pch <- "*"
bw_theme$plot.symbol$cex <- 2
bw_theme$strip.background$col <- "grey80"

l_bw <- update(bw_lattice, par.settings = bw_theme)

print(l_bw)
```

```{r latt-panel-bw, tidy = FALSE, fig.cap = "A **lattice** panel boxplot with colored boxes and box widths relative to the number of observations.", fig.align = 'center'}
bw_lattice <- bwplot(price ~ color | cut, data = diamonds,
                     asp = 1, as.table = TRUE, varwidth = TRUE)
l_bw <- update(bw_lattice, par.settings = bw_theme, xlab = "color", 
               fill = clrs_hcl(7),
               xscale.components = xscale.components.subticks,
               yscale.components = yscale.components.subticks)

print(l_bw)
```

In addition to the rather obvious provision of a color palette to fill the boxes, in this final boxplot we have also told **lattice** to adjust the widths of the boxes so that they reflect the relative sizes of the data samples for each of the factors (colors). This is a rather handy way of providing insight into the data distribution along the factor of the x-axis. We can show this without having to provide any additional plot to highlight that some of the factor levels (i.e. colors) are much less represented than others ('J' compared to 'G', for example, especially for the 'Ideal' quality class). 


## Box-and-Whisker Plots (ggplot2)

As much as we are **lattice** enthusiasts, we always end up drawing boxplots with **ggplot2** because they look so much nicer, meaning that there's no need to modify so many graphical parameter settings in order to get an acceptable result. You will see what we mean when we plot a **ggplot2** version using the default settings.

```{r gg-bw1, tidy = FALSE, fig.cap = "A basic **ggplot2** boxplot.", fig.align = 'center'}
bw_ggplot <- ggplot(diamonds, aes(x = color, y = price))

g_bw <- bw_ggplot + geom_boxplot()

print(g_bw)
```

This is much better straight away! And, as we've already seen, the faceting requires also just one more line...

```{r gg-facet-bw, tidy = FALSE, fig.cap = "A faceted **ggplot2** boxplot.", fig.align = 'center'}
bw_ggplot <- ggplot(diamonds, aes(x = color, y = price))

g_bw <- bw_ggplot + 
  geom_boxplot(fill = "grey90") +
  facet_wrap(~ cut)

print(g_bw)
```

So far, you may have gotten the impression that pretty much everything is a little bit easier the **ggplot2** way. Well, a lot of things are, but some are not. If we wanted to highlight the relative sample sizes of the different color levels like we did earlier in **lattice** (using ```varwidth = TRUE```) we have to put a little more effort into **ggplot2**. Meaning, we have to calculate this ourselves. There is no built-in functionality for this feature (yet), at least not to our knowledge.

But anyway, it is not too complicated. The equation for this adjustment is rather straightforward, we simply take the square root of the counts for each color and divide it by the overall number of observations. Then we standardize this relative to the maximum of this calculation. As a final step, we need to break this down to each of the panels of the plot. This is the toughest part of it. We won't go into any detail here, but the ```llply()``` part of the following code chunk is basically the equivalent of what is going on behind the scenes of **lattice** (though the latter most likely does not use ```llply()```).

Anyway, it does not require too many lines of code to achieve the box width adjustment in **ggplot2**.

```{r gg-facet-width-bw, tidy = FALSE, fig.cap = "A faceted **ggplot2** boxplot with colored boxes and box widths relative to number of observations.", fig.align = 'center'}
w <- sqrt(table(diamonds$color)/nrow(diamonds))
### standardize w to maximum value
w <- w / max(w)

g_bw <- bw_ggplot + 
  facet_wrap(~ cut) +
  llply(unique(diamonds$color), 
        function(i) geom_boxplot(fill = clrs_hcl(7)[i],
                                 width = w[i], outlier.shape = "*",
                                 outlier.size = 3,
                                 data = subset(diamonds, color == i)))

print(g_bw)
```

The result is very similar to what we have achieved earlier. In summary, **lattice** needs a little more care to adjust the standard graphical parameters, whereas **ggplot2** requires us to manually calculate the width of the boxes. We leave it up to you which way suits you better... the two of us have already made our choice a few years ago ;-)

Boxplots are, as mentioned above, a brilliant way to visualize data distribution(s). Their strength lies in the comparability of different classes as they are plotted next to each other using a common scale. Another, more classical - as parametric - way are histograms and density plots.


## Histograms and Density Plots (lattice)

The classic way to visualize the distribution of any data are histograms. They are closely related to density plots, where the individual data points are not binned into certain classes but a continuous density function is calculated to show the distribution. Both approaches reflect a certain level of abstraction (binning vs. functional representation), therefore a general formulation of which of them is more accepted is hard. In any case, the both achieve exactly the same result, they will show us the distribution of our data.

As is to be expected with **lattice**, the default plotting routine does not really satisfy the (or maybe better our) aesthetic expectations.

```{r altt-hist, tidy = FALSE, fig.cap = "A basic histogram produced with **lattice**.", fig.align = 'center'}
hist_lattice <- histogram(~ price, data = diamonds)
hist_lattice
```

This is even worse for the default density plot...

```{r latt-dens, tidy = FALSE, fig.cap = "A basic density plot produced with **lattice**.", fig.align = 'center'}
dens_lattice <- densityplot(~ price, data = diamonds)
dens_lattice
```

Yet, as we've already adjusted our global graphical parameter settings, we can now easily modify this.

```{r latt-panel-hist, tidy = FALSE, fig.cap = "A **lattice** panel histogram with modified graphical parameter settings.", fig.align = 'center'}
hist_lattice <- histogram(~ price | color, 
                          data = diamonds,
                          as.table = TRUE,
                          par.settings = my_theme)

l_his <- hist_lattice

print(l_his)
```

Now, this is a plot that every journal editor will very likely accept.

Until now, we have seen how to condition our plots according to one factorial variable (```diamonds$cut```). It is, in theory, possible to condition plots on any number of factorial variable, though more than two is seldom advisable. Two, however, is definitely acceptable and still easy enough to perceive and interpret. In **lattice** this is generally formulated as 

```
y ~ x | g + f
```

where ```g``` and ```f``` are the factorial variables used for the conditioning.

In the below code chunk, we are first creating our plot object. Then, we are using a function called ```useOuterStrips()``` which makes sure that the strips that correspond to the conditioning variables are plotted on both the top and the left side of our plot. The default **lattice** setting is to plot both at the top, which makes the navigation through the plot by the viewer a little more difficult.

Another default setting for density plots in **lattice** is to plot a point (circle) for each observation of our variable (price) at the bottom of the plot along the x-axis. In our case, as we have a lot of data points, this is not desirable, so we set ```plot.points = FALSE```.

```{r latt-panel-dens, tidy = FALSE, fig.cap = "A panel density plot conditioned according to two variables using **lattice**.", fig.align = 'center'}
dens_lattice <- densityplot(~ price | cut + color, 
                            data = diamonds,
                            as.table = TRUE,
                            par.settings = my_theme,
                            plot.points = FALSE,
                            between = list(x = 0.2, y = 0.2),
                            scales = list(x = list(rot = 45)))

l_den <- useOuterStrips(dens_lattice)

print(l_den)
```

You may have noticed that the lines of the density plot are plotted in a light shade of blue (cornflowerblue to be precise). It is up to you to change this...

Another thing you may notice when looking at the above plot is that the x-axis labels are rotated by 45 degrees. This one we also leave up to you to figure out... ;-)


## Histograms and Density Plots (ggplot2)

Much like with boxplots, the default settings of **ggplot2** are quite a bit nicer for both histograms and density plots.

```{r gg-hist-echo, tidy = FALSE, eval = FALSE}
hist_ggplot <- ggplot(diamonds, aes(x = price))

g_his <- hist_ggplot +
  geom_histogram()

print(g_his)
```

```{r gg-hist-eval, tidy = FALSE, fig.cap = "A basic histogram produced with **ggplot2**.", fig.align = 'center', echo = FALSE}
hist_ggplot <- ggplot(diamonds, aes(x = price))

g_his <- hist_ggplot +
  geom_histogram()

suppressMessages(print(g_his))
```

One thing that is really nice about the **ggplot2** density plots is that it is so easy to fill the area under the curve which really helps the visual representation of the data.

```{r gg-dens, tidy = FALSE, fig.cap = "A basic density plot produced with **ggplot2**.", fig.align = 'center'}
dens_ggplot <- ggplot(diamonds, aes(x = price))

g_den <- dens_ggplot +
  geom_density(fill = "black", alpha = 0.5)

print(g_den)
```

Just as before, we are encountering the rather peculiar way of **ggplot2** to adjust certain default settings to suit our needs (likes). If we wanted to show percentages instead of counts for the histograms, we again need to use the strange ```..something..``` syntax.

Another thing that we want to highlight in the following code chunk is the way to achieve binary conditioning in **ggplot2**. This can be achieved through

```
facet_grid(g ~ f)
```

where, again, ```g``` and ```f``` are the two variables used for conditioning.

```{r gg-facet-hist, tidy = FALSE, fig.cap = "A faceted **ggplot2** histogram with percentages on the y-axis.", fig.align = 'center', message = FALSE}
g_his <- hist_ggplot +
  geom_histogram(aes(y = ..ncount..)) +
  scale_y_continuous(labels = percent_format()) +
  facet_grid(color ~ cut) + 
  ylab("Percent")

print(g_his)
```

Similar to our **lattice** approach we're going to rotate the x-axis labels by 45 degrees.

```{r gg-facet-density, tidy = FALSE, fig.cap = "A faceted **ggplot2** density plot conditioned according to two variables.", fig.align = 'center'}
dens_ggplot <- ggplot(diamonds, aes(x = price))

g_den <- dens_ggplot +
  geom_density(fill = "black", alpha = 0.5) +
  facet_grid(color ~ cut) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(g_den)
```

Okay, another thing we might want to show is a certain estimated value (like the mean of our sample) including error bars.


## Plotting Error Bars (lattice)

Honestly, **lattice** sucks at plotting error bars... Therefore, we will only explore one way of achieving this. In case you really want to explore this further, we refer you to StackOverflow and other R related forums and lists. You will possibly find a workable solution there, but we doubt that you will like it. As you will see in Section `{#gg-err}`, error bars are much easier plotted using **ggplot2**.

Anyway, here is a solution built on a function called `Dotplot()` (not to be mistaken with `lattice::dotplot()`) from **Hmisc** [@Harrell2017].

```{r latt-err, tidy = FALSE, fig.cap = "A **lattice** dotplot including error bars produced with `Hmisc::Dotplot()`.", fig.align = 'center'}
my_theme$dot.symbol$col <- "black"
my_theme$dot.symbol$cex <- 1.5
my_theme$plot.line$col <- "black"
my_theme$plot.line$lwd <- 1.5

dmod <- lm(price ~ cut, data = diamonds)
cuts <- data.frame(cut = unique(diamonds$cut), 
                   predict(dmod, data.frame(cut = unique(diamonds$cut)), 
                           se = TRUE)[c("fit", "se.fit")])

errbar_lattice <- Hmisc::Dotplot(cut ~ Cbind(fit, 
                                             fit + se.fit, 
                                             fit - se.fit),
                                 data = cuts, 
                                 par.settings = my_theme)

l_err <- errbar_lattice

print(l_err)
```


## Plotting Error Bars (ggplot2) {#gg-err}

As mentioned above, when plotting error bars **ggplot2** is much easier. Whether this is because of the general ongoing discussion about the usefulness of these plots we do not want to judge.

Anyway, plotting error bars in **ggplot2** is as easy as everything else...

```{r gg-err, tidy = FALSE, fig.cap = "A **ggplot2** dotplot including error bars and using a classic theme.", fig.align = 'center'}
errbar_ggplot <- ggplot(cuts, aes(cut, fit, ymin = fit - se.fit, 
                                  ymax=fit + se.fit))
g_err <- errbar_ggplot + 
  geom_pointrange() +
  coord_flip() +
  theme_classic()

print(g_err)
```

Especially, when plotting them as part of a bar plot.

```{r gg-err-bar, tidy = FALSE, fig.cap = "A **ggplot2** bar plot including error bars and using a classic theme.", fig.align = 'center'}
g_err <- errbar_ggplot + 
  geom_bar(stat = "identity", fill = "grey80") +
  geom_errorbar(width = 0.2) +
  coord_flip() +
  theme_classic()

print(g_err)
```

Just as before with the box widths, though, applying this to each facet is a little more complicated... But still, trust us on this, much easier than to achieve the same result in **lattice**.

```{r gg-facet-err-bar, tidy = FALSE, concordance = TRUE, fig.cap = "A **ggplot2** panel bar plot with error bars and modified fill colors.", fig.align = 'center'}
errbar_ggplot_facets <- ggplot(diamonds, aes(x = color, y = price))

### function to calculate the standard error of the mean
se <- function(x) sd(x)/sqrt(length(x))

### function to be applied to each panel/facet
myFun <- function(x) {
  data.frame(ymin = mean(x) - se(x), 
             ymax = mean(x) + se(x), 
             y = mean(x))
  }

g_err_f <- errbar_ggplot_facets + 
  stat_summary(fun.y = mean, geom = "bar", 
               fill = rep(clrs_hcl(7), 5)) + 
  stat_summary(fun.data = myFun, geom = "linerange") + 
  facet_wrap(~ cut)

print(g_err_f)
```

## Plotting Error Bars (base graphics)

Although the focus is mostly put on other packages in this tutorial, it is worth mentioning at this point that R base **graphics** also offer opportunities to create plots with error bars. For example, `plotCI()` from **plotrix** provides an approach that lets us recreate (at least more or less) our **lattice**-based Figure \@ref(fig:latt-err).

```{r plotCI, tidy = FALSE, fig.cap = "A base **graphics** scatter plot with error bars.", fig.align = 'center', fis.asp = 1, message = FALSE}
library(plotrix)

# increase left-side margin for horizontal tick labels to fit on page
par(mar = c(5, 8, 2, 2), las = 1) # see ?par
plotCI(cuts$fit, as.numeric(cuts$cut), uiw = cuts$se.fit, err = "x", yaxt = "n", 
       pch = 21, pt.bg = "black", xlab = "fit", ylab = "")

# add y-axis title
title(ylab = "cut", line = 6) # see ?title

# add y-axis tick labels
lvl = levels(cuts$cut)
axis(side = 2, at = 1:length(lvl), labels = lvl)
```

```{r tmp}
invisible(dev.off()) # if not run, edits to par() persist
```